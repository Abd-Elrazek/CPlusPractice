#include <iostream>#include <exception>using namespace std;template< class Comparable>class BinarySearchTree;template <class Comparable>class BinaryNode{private:    Comparable  element;    BinaryNode *left;    BinaryNode *right;    int size;        BinaryNode( const Comparable & theElement, BinaryNode *lt,               BinaryNode *rt, int sz = 1 )    : element( theElement ), left( lt ), right( rt ), size( sz ) { }        friend class BinarySearchTree<Comparable>;public:    Comparable getElement() { return element; }};template <class Comparable>class BinarySearchTree{public:     typedef BinaryNode<Comparable> Node;        BinarySearchTree( ) : root( NULL ) { } // Construct the tree.    ~BinarySearchTree( ){ makeEmpty( ); } // Destructor for the tree.            Node * find(Comparable obj) { return find(root, obj); }    void printInRange(const Comparable low, const Comparable high) { printInRange(root, low, high); }    void negateTree() { negateTree(root); }    int countNodesWithOneChild() { return countNodesWithOneChild(root); }    float averageNodeDepth() { return averageNodeDepth(root, 0); }    int treeSize( ) const { return treeSize(root); }    bool isEmpty( ) const { return root == NULL; }    void makeEmpty( ) { makeEmpty( root ); }    void insert( const Comparable & x ) { insert( x, root ); }    private:    Node * root;    Node * find(Node * node, Comparable obj) const;    void printInRange(Node * node, const Comparable low, const Comparable high);    void negateTree(Node * node);    int countNodesWithOneChild(Node * node);    float averageNodeDepth(Node * node, int depth);    int treeSize( Node *t ) const { return t == NULL ? 0 : t->size; }    Comparable const * elementAt( Node *t ) const;    void insert( const Comparable & x, Node * & t );    void makeEmpty( Node * & t ) const;    Node * clone( Node *t ) const;};template <class Comparable>BinaryNode<Comparable> * BinarySearchTree<Comparable>::find(Node * node, const Comparable obj) const {    if (node == NULL) return NULL;    if (obj == node->element) return node;    if (obj > node->element) return find(node->right, obj);    if (obj < node->element) return find(node->left,  obj);    return NULL;}template <class Comparable>void BinarySearchTree<Comparable>::printInRange(Node * node, const Comparable low, const Comparable high) {    if (node == NULL) return;    if (node->element > high) { printInRange(node->left,  low, high); return; }    if (node->element < low)  { printInRange(node->right, low, high); return; }    // We know our node must be in the inclusive range [low, high]    cout << node->element << " ";    printInRange(node->right, low, high);    printInRange(node->left,  low, high);}template <class Comparable>void BinarySearchTree<Comparable>::negateTree(Node * node) {    if (node == NULL) return;    node->element *= -1;    Node * tmp = node->left;    node->left = node->right;    node->right = tmp;    negateTree(node->left);    negateTree(node->right);}template <class Comparable>int BinarySearchTree<Comparable>::countNodesWithOneChild(Node * node) {    if (node == NULL) return 0;    int sum = ((node->left?0:1) + (node->right?0:1) == 1) ? 1 : 0;    return sum + countNodesWithOneChild(node->left) + countNodesWithOneChild(node->right);}template <class Comparable>float BinarySearchTree<Comparable>::averageNodeDepth(Node * node, int depth) {    if (node == NULL) return 0;    if (depth == 0)        return ((float) (averageNodeDepth(node->left, 1) + averageNodeDepth(node->right, 1))) / ((float) treeSize());    return depth + averageNodeDepth(node->left, depth + 1) + averageNodeDepth(node->right, depth + 1);}template <class Comparable>Comparable const * BinarySearchTree<Comparable>::elementAt( Node *t ) const{    if( t == NULL )        return NULL;    else        return &(t->element);}template <class Comparable>void BinarySearchTree<Comparable>::insert( const Comparable & x, Node * & t ){    if( t == NULL )        t = new Node( x, NULL, NULL, 0 );    else if( x < t->element )        insert( x, t->left );    else if( t->element < x )        insert( x, t->right );    else        throw exception( );        t->size++;}template <class Comparable>void BinarySearchTree<Comparable>::makeEmpty( Node * & t ) const{    if( t != NULL )    {        makeEmpty( t->left );        makeEmpty( t->right );        delete t;        t = NULL;    }    }int main() {    int v[] = {6,1,7,12,90,34,56,2,3,45,100};    BinarySearchTree<int> b;    for (int i = 0; i < sizeof(v)/sizeof(int); i++) b.insert(v[i]);    BinaryNode<int> * n = b.find(7);    if (n != NULL) cout << n->getElement() << endl;    b.printInRange(10, 45);    cout << endl;    b.negateTree();    cout << b.countNodesWithOneChild() << endl;    cout << b.averageNodeDepth() << endl;}